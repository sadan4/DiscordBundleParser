import {
    type AmpersandAmpersandEqualsToken,
    type ArrayBindingPattern,
    type ArrayLiteralExpression,
    type ArrayTypeNode,
    type ArrowFunction,
    type AsExpression,
    type AssertClause,
    type AssertEntry,
    type AsteriskToken,
    type AwaitExpression,
    type BigIntLiteral,
    type BinaryExpression,
    type BindingElement,
    type Block,
    type BreakStatement,
    type Bundle,
    type CallExpression,
    type CallSignatureDeclaration,
    type CaseBlock,
    type CaseClause,
    type CaseKeyword,
    type CatchClause,
    type ClassDeclaration,
    type ClassExpression,
    type ClassStaticBlockDeclaration,
    type ColonToken,
    type CommaListExpression,
    type ComputedPropertyName,
    type ConditionalExpression,
    type ConditionalTypeNode,
    type ConstKeyword,
    type ConstructorDeclaration,
    type ConstructorTypeNode,
    type ConstructSignatureDeclaration,
    type ContinueStatement,
    type DebuggerStatement,
    type Decorator,
    type DefaultClause,
    type DeleteExpression,
    type DoStatement,
    type DotDotDotToken,
    type DotToken,
    type ElementAccessExpression,
    type EmptyStatement,
    type EndOfFileToken,
    type EnumDeclaration,
    type EnumMember,
    type EqualsGreaterThanToken,
    type EqualsToken,
    type ExclamationToken,
    type ExportAssignment,
    type ExportDeclaration,
    type ExportSpecifier,
    type ExpressionStatement,
    type ExpressionWithTypeArguments,
    type ExternalModuleReference,
    type ForInStatement,
    type ForOfStatement,
    type ForStatement,
    type FunctionDeclaration,
    type FunctionExpression,
    type FunctionTypeNode,
    type GetAccessorDeclaration,
    type HeritageClause,
    type Identifier,
    type IfStatement,
    type ImportAttribute,
    type ImportAttributes,
    type ImportClause,
    type ImportDeclaration,
    type ImportEqualsDeclaration,
    type ImportSpecifier,
    type ImportTypeAssertionContainer,
    type ImportTypeNode,
    type IndexedAccessTypeNode,
    type IndexSignatureDeclaration,
    type InferTypeNode,
    type InterfaceDeclaration,
    type IntersectionTypeNode,
    type JSDoc,
    type JSDocAllType,
    type JSDocAugmentsTag,
    type JSDocAuthorTag,
    type JSDocCallbackTag,
    type JSDocClassTag,
    type JSDocDeprecatedTag,
    type JSDocEnumTag,
    type JSDocFunctionType,
    type JSDocImplementsTag,
    type JSDocImportTag,
    type JSDocLink,
    type JSDocLinkCode,
    type JSDocLinkPlain,
    type JSDocMemberName,
    type JSDocNamepathType,
    type JSDocNameReference,
    type JSDocNonNullableType,
    type JSDocNullableType,
    type JSDocOptionalType,
    type JSDocOverloadTag,
    type JSDocOverrideTag,
    type JSDocParameterTag,
    type JSDocPrivateTag,
    type JSDocPropertyTag,
    type JSDocProtectedTag,
    type JSDocPublicTag,
    type JSDocReadonlyTag,
    type JSDocReturnTag,
    type JSDocSatisfiesTag,
    type JSDocSeeTag,
    type JSDocSignature,
    type JSDocTemplateTag,
    type JSDocText,
    type JSDocThisTag,
    type JSDocThrowsTag,
    type JSDocTypedefTag,
    type JSDocTypeExpression,
    type JSDocTypeLiteral,
    type JSDocTypeTag,
    type JSDocUnknownType,
    type JSDocVariadicType,
    type JsxAttribute,
    type JsxAttributes,
    type JsxClosingElement,
    type JsxClosingFragment,
    type JsxElement,
    type JsxExpression,
    type JsxFragment,
    type JsxNamespacedName,
    type JsxOpeningElement,
    type JsxOpeningFragment,
    type JsxSelfClosingElement,
    type JsxSpreadAttribute,
    type JsxText,
    type KeywordToken,
    type LabeledStatement,
    type LiteralTypeNode,
    type MappedTypeNode,
    type MetaProperty,
    type MethodDeclaration,
    type MethodSignature,
    type MinusToken,
    type MissingDeclaration,
    type ModuleBlock,
    type ModuleDeclaration,
    type NamedExports,
    type NamedImports,
    type NamedTupleMember,
    type NamespaceExport,
    type NamespaceExportDeclaration,
    type NamespaceImport,
    type NewExpression,
    type Node,
    type NonNullExpression,
    type NoSubstitutionTemplateLiteral,
    type NotEmittedStatement,
    type NotEmittedTypeElement,
    type NumericLiteral,
    type ObjectBindingPattern,
    type ObjectLiteralExpression,
    type OmittedExpression,
    type OptionalTypeNode,
    type ParameterDeclaration,
    type ParenthesizedExpression,
    type ParenthesizedTypeNode,
    type PartiallyEmittedExpression,
    type PlusToken,
    type PostfixUnaryExpression,
    type PrefixUnaryExpression,
    type PrivateIdentifier,
    type PropertyAccessExpression,
    type PropertyAssignment,
    type PropertyDeclaration,
    type PropertySignature,
    type QualifiedName,
    type QuestionDotToken,
    type QuestionQuestionEqualsToken,
    type QuestionToken,
    type RegularExpressionLiteral,
    type RestTypeNode,
    type ReturnStatement,
    type SatisfiesExpression,
    type SemicolonClassElement,
    type SetAccessorDeclaration,
    type ShorthandPropertyAssignment,
    type SourceFile,
    type SpreadAssignment,
    type SpreadElement,
    type StringLiteral,
    type SwitchStatement,
    SyntaxKind,
    type SyntaxList,
    type SyntheticExpression,
    type TaggedTemplateExpression,
    type TemplateExpression,
    type TemplateHead,
    type TemplateLiteralTypeNode,
    type TemplateLiteralTypeSpan,
    type TemplateMiddle,
    type TemplateSpan,
    type TemplateTail,
    type ThisTypeNode,
    type ThrowStatement,
    type Token,
    type TryStatement,
    type TupleTypeNode,
    type TypeAliasDeclaration,
    type TypeAssertion,
    type TypeLiteralNode,
    type TypeOfExpression,
    type TypeOperatorNode,
    type TypeParameterDeclaration,
    type TypePredicateNode,
    type TypeQueryNode,
    type TypeReferenceNode,
    type UnionTypeNode,
    type VariableDeclaration,
    type VariableDeclarationList,
    type VariableStatement,
    type VoidExpression,
    type WhileStatement,
    type WithStatement,
    type YieldExpression,
} from "typescript";

export declare const TypeKey: unique symbol;
// eslint-disable-next-line no-redeclare
export type TypeKey = typeof TypeKey;

export type IsAny<T> = 0 extends (1 & T) ? true : false;

export type NoNeverValues<T> = {
    [K in keyof T as[T[K]] extends [never] ? never : K]: T[K];
};

export type Narrower<T, U> = T extends U ? T : U extends T ? U : never;

type TypedNodes = {
    [K in keyof typeof SyntaxKind]: Node & { kind: typeof SyntaxKind[K]; };
};

type InverseSyntaxKind = {
    [K in keyof typeof SyntaxKind as typeof SyntaxKind[K]]: Exclude<K, InvalidTypes>;
};

type MapNodeImpl<T extends { kind: SyntaxKind; }> = {
    [K in keyof T]:
    0 extends (1 & T[K]) // is any            
        ? T[K]
        : T[K] extends Node | null | undefined
            ? MapNode<T[K]>
            : T[K] extends ArrayLike<infer Nodes extends Node> | null | undefined
                ? MapNode<Nodes>[]
                : T[K];
} & { [TypeKey]: InverseSyntaxKind[T["kind"]]; };

type MapNode<
    _T,
    T extends { kind: SyntaxKind; } = _T & {} extends { kind: SyntaxKind; } ? _T & {} : never,
    N = Exclude<_T, T>,
> = MapNodeImpl<T> | N;

export type UnmapNode<T> = T extends MapNode<infer _, infer N> ? N : never;

interface UnmappedNodeTypes extends TypedNodes {
    Unknown: never;
    EndOfFileToken: EndOfFileToken;
    SingleLineCommentTrivia: never;
    MultiLineCommentTrivia: never;
    NewLineTrivia: never;
    WhitespaceTrivia: never;
    ShebangTrivia: never;
    ConflictMarkerTrivia: never;
    NonTextFileMarkerTrivia: never;
    NumericLiteral: NumericLiteral;
    BigIntLiteral: BigIntLiteral;
    StringLiteral: StringLiteral;
    JsxText: JsxText;
    JsxTextAllWhiteSpaces: never;
    RegularExpressionLiteral: RegularExpressionLiteral;
    NoSubstitutionTemplateLiteral: NoSubstitutionTemplateLiteral;
    TemplateHead: TemplateHead;
    TemplateMiddle: TemplateMiddle;
    TemplateTail: TemplateTail;
    OpenBraceToken: Token<SyntaxKind.OpenBraceToken>;
    CloseBraceToken: Token<SyntaxKind.CloseBraceToken>;
    OpenParenToken: Token<SyntaxKind.OpenParenToken>;
    CloseParenToken: Token<SyntaxKind.CloseParenToken>;
    OpenBracketToken: Token<SyntaxKind.OpenBracketToken>;
    CloseBracketToken: Token<SyntaxKind.CloseBracketToken>;
    DotToken: DotToken;
    DotDotDotToken: DotDotDotToken;
    SemicolonToken: Token<SyntaxKind.SemicolonToken>;
    CommaToken: Token<SyntaxKind.CommaToken>;
    QuestionDotToken: QuestionDotToken;
    LessThanToken: Token<SyntaxKind.LessThanToken>;
    LessThanSlashToken: Token<SyntaxKind.LessThanSlashToken>;
    GreaterThanToken: Token<SyntaxKind.GreaterThanToken>;
    LessThanEqualsToken: Token<SyntaxKind.LessThanEqualsToken>;
    GreaterThanEqualsToken: Token<SyntaxKind.GreaterThanEqualsToken>;
    EqualsEqualsToken: Token<SyntaxKind.EqualsEqualsToken>;
    ExclamationEqualsToken: Token<SyntaxKind.ExclamationEqualsToken>;
    EqualsEqualsEqualsToken: Token<SyntaxKind.EqualsEqualsEqualsToken>;
    ExclamationEqualsEqualsToken: Token<SyntaxKind.ExclamationEqualsEqualsToken>;
    EqualsGreaterThanToken: EqualsGreaterThanToken;
    PlusToken: PlusToken;
    MinusToken: MinusToken;
    AsteriskToken: AsteriskToken;
    AsteriskAsteriskToken: Token<SyntaxKind.AsteriskAsteriskToken>;
    SlashToken: Token<SyntaxKind.SlashToken>;
    PercentToken: Token<SyntaxKind.PercentToken>;
    PlusPlusToken: Token<SyntaxKind.PlusPlusToken>;
    MinusMinusToken: Token<SyntaxKind.MinusMinusToken>;
    LessThanLessThanToken: Token<SyntaxKind.LessThanLessThanToken>;
    GreaterThanGreaterThanToken: Token<SyntaxKind.GreaterThanGreaterThanToken>;
    GreaterThanGreaterThanGreaterThanToken: Token<SyntaxKind.GreaterThanGreaterThanGreaterThanToken>;
    AmpersandToken: Token<SyntaxKind.AmpersandToken>;
    BarToken: Token<SyntaxKind.BarToken>;
    CaretToken: Token<SyntaxKind.CaretToken>;
    ExclamationToken: ExclamationToken;
    TildeToken: Token<SyntaxKind.TildeToken>;
    AmpersandAmpersandToken: Token<SyntaxKind.AmpersandAmpersandToken>;
    BarBarToken: Token<SyntaxKind.BarBarToken>;
    QuestionToken: QuestionToken;
    ColonToken: ColonToken;
    AtToken: Token<SyntaxKind.AtToken>;
    QuestionQuestionToken: Token<SyntaxKind.QuestionQuestionToken>;
    /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
    BacktickToken: Token<SyntaxKind.BacktickToken>;
    /** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */
    HashToken: Token<SyntaxKind.HashToken>;
    EqualsToken: EqualsToken;
    PlusEqualsToken: Token<SyntaxKind.PlusEqualsToken>;
    MinusEqualsToken: Token<SyntaxKind.MinusEqualsToken>;
    AsteriskEqualsToken: Token<SyntaxKind.AsteriskEqualsToken>;
    AsteriskAsteriskEqualsToken: Token<SyntaxKind.AsteriskAsteriskEqualsToken>;
    SlashEqualsToken: Token<SyntaxKind.SlashEqualsToken>;
    PercentEqualsToken: Token<SyntaxKind.PercentEqualsToken>;
    LessThanLessThanEqualsToken: Token<SyntaxKind.LessThanLessThanEqualsToken>;
    GreaterThanGreaterThanEqualsToken: Token<SyntaxKind.GreaterThanGreaterThanEqualsToken>;
    GreaterThanGreaterThanGreaterThanEqualsToken: Token<SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken>;
    AmpersandEqualsToken: Token<SyntaxKind.AmpersandEqualsToken>;
    BarEqualsToken: Token<SyntaxKind.BarEqualsToken>;
    BarBarEqualsToken: Token<SyntaxKind.BarBarEqualsToken>;
    AmpersandAmpersandEqualsToken: AmpersandAmpersandEqualsToken;
    QuestionQuestionEqualsToken: QuestionQuestionEqualsToken;
    CaretEqualsToken: Token<SyntaxKind.CaretEqualsToken>;
    Identifier: Identifier;
    PrivateIdentifier: PrivateIdentifier;
    BreakKeyword: KeywordToken<SyntaxKind.BreakKeyword>;
    CaseKeyword: CaseKeyword;
    CatchKeyword: KeywordToken<SyntaxKind.CatchKeyword>;
    ClassKeyword: KeywordToken<SyntaxKind.ClassKeyword>;
    ConstKeyword: ConstKeyword;
    ContinueKeyword: KeywordToken<SyntaxKind.ContinueKeyword>;
    DebuggerKeyword: KeywordToken<SyntaxKind.DebuggerKeyword>;
    DefaultKeyword: KeywordToken<SyntaxKind.DefaultKeyword>;
    DeleteKeyword: KeywordToken<SyntaxKind.DeleteKeyword>;
    DoKeyword: KeywordToken<SyntaxKind.DoKeyword>;
    ElseKeyword: KeywordToken<SyntaxKind.ElseKeyword>;
    EnumKeyword: KeywordToken<SyntaxKind.EnumKeyword>;
    ExportKeyword: KeywordToken<SyntaxKind.ExportKeyword>;
    ExtendsKeyword: KeywordToken<SyntaxKind.ExtendsKeyword>;
    FalseKeyword: KeywordToken<SyntaxKind.FalseKeyword>;
    FinallyKeyword: KeywordToken<SyntaxKind.FinallyKeyword>;
    ForKeyword: KeywordToken<SyntaxKind.ForKeyword>;
    FunctionKeyword: KeywordToken<SyntaxKind.FunctionKeyword>;
    IfKeyword: KeywordToken<SyntaxKind.IfKeyword>;
    ImportKeyword: KeywordToken<SyntaxKind.ImportKeyword>;
    InKeyword: KeywordToken<SyntaxKind.InKeyword>;
    InstanceOfKeyword: KeywordToken<SyntaxKind.InstanceOfKeyword>;
    NewKeyword: KeywordToken<SyntaxKind.NewKeyword>;
    NullKeyword: KeywordToken<SyntaxKind.NullKeyword>;
    ReturnKeyword: KeywordToken<SyntaxKind.ReturnKeyword>;
    SuperKeyword: KeywordToken<SyntaxKind.SuperKeyword>;
    SwitchKeyword: KeywordToken<SyntaxKind.SwitchKeyword>;
    ThisKeyword: KeywordToken<SyntaxKind.ThisKeyword>;
    ThrowKeyword: KeywordToken<SyntaxKind.ThrowKeyword>;
    TrueKeyword: KeywordToken<SyntaxKind.TrueKeyword>;
    TryKeyword: KeywordToken<SyntaxKind.TryKeyword>;
    TypeOfKeyword: KeywordToken<SyntaxKind.TypeOfKeyword>;
    VarKeyword: KeywordToken<SyntaxKind.VarKeyword>;
    VoidKeyword: KeywordToken<SyntaxKind.VoidKeyword>;
    WhileKeyword: KeywordToken<SyntaxKind.WhileKeyword>;
    WithKeyword: KeywordToken<SyntaxKind.WithKeyword>;
    ImplementsKeyword: KeywordToken<SyntaxKind.ImplementsKeyword>;
    InterfaceKeyword: KeywordToken<SyntaxKind.InterfaceKeyword>;
    LetKeyword: KeywordToken<SyntaxKind.LetKeyword>;
    PackageKeyword: KeywordToken<SyntaxKind.PackageKeyword>;
    PrivateKeyword: KeywordToken<SyntaxKind.PrivateKeyword>;
    ProtectedKeyword: KeywordToken<SyntaxKind.ProtectedKeyword>;
    PublicKeyword: KeywordToken<SyntaxKind.PublicKeyword>;
    StaticKeyword: KeywordToken<SyntaxKind.StaticKeyword>;
    YieldKeyword: KeywordToken<SyntaxKind.YieldKeyword>;
    AbstractKeyword: KeywordToken<SyntaxKind.AbstractKeyword>;
    AccessorKeyword: KeywordToken<SyntaxKind.AccessorKeyword>;
    AsKeyword: KeywordToken<SyntaxKind.AsKeyword>;
    AssertsKeyword: KeywordToken<SyntaxKind.AssertsKeyword>;
    AssertKeyword: KeywordToken<SyntaxKind.AssertKeyword>;
    AnyKeyword: KeywordToken<SyntaxKind.AnyKeyword>;
    AsyncKeyword: KeywordToken<SyntaxKind.AsyncKeyword>;
    AwaitKeyword: KeywordToken<SyntaxKind.AwaitKeyword>;
    BooleanKeyword: KeywordToken<SyntaxKind.BooleanKeyword>;
    ConstructorKeyword: KeywordToken<SyntaxKind.ConstructorKeyword>;
    DeclareKeyword: KeywordToken<SyntaxKind.DeclareKeyword>;
    GetKeyword: KeywordToken<SyntaxKind.GetKeyword>;
    InferKeyword: KeywordToken<SyntaxKind.InferKeyword>;
    IntrinsicKeyword: KeywordToken<SyntaxKind.IntrinsicKeyword>;
    IsKeyword: KeywordToken<SyntaxKind.IsKeyword>;
    KeyOfKeyword: KeywordToken<SyntaxKind.KeyOfKeyword>;
    ModuleKeyword: KeywordToken<SyntaxKind.ModuleKeyword>;
    NamespaceKeyword: KeywordToken<SyntaxKind.NamespaceKeyword>;
    NeverKeyword: KeywordToken<SyntaxKind.NeverKeyword>;
    OutKeyword: KeywordToken<SyntaxKind.OutKeyword>;
    ReadonlyKeyword: KeywordToken<SyntaxKind.ReadonlyKeyword>;
    RequireKeyword: KeywordToken<SyntaxKind.RequireKeyword>;
    NumberKeyword: KeywordToken<SyntaxKind.NumberKeyword>;
    ObjectKeyword: KeywordToken<SyntaxKind.ObjectKeyword>;
    SatisfiesKeyword: KeywordToken<SyntaxKind.SatisfiesKeyword>;
    SetKeyword: KeywordToken<SyntaxKind.SetKeyword>;
    StringKeyword: KeywordToken<SyntaxKind.StringKeyword>;
    SymbolKeyword: KeywordToken<SyntaxKind.SymbolKeyword>;
    TypeKeyword: KeywordToken<SyntaxKind.TypeKeyword>;
    UndefinedKeyword: KeywordToken<SyntaxKind.UndefinedKeyword>;
    UniqueKeyword: KeywordToken<SyntaxKind.UniqueKeyword>;
    UnknownKeyword: KeywordToken<SyntaxKind.UnknownKeyword>;
    UsingKeyword: KeywordToken<SyntaxKind.UsingKeyword>;
    FromKeyword: KeywordToken<SyntaxKind.FromKeyword>;
    GlobalKeyword: KeywordToken<SyntaxKind.GlobalKeyword>;
    BigIntKeyword: KeywordToken<SyntaxKind.BigIntKeyword>;
    OverrideKeyword: KeywordToken<SyntaxKind.OverrideKeyword>;
    OfKeyword: KeywordToken<SyntaxKind.OfKeyword>;
    QualifiedName: QualifiedName;
    ComputedPropertyName: ComputedPropertyName;
    TypeParameter: TypeParameterDeclaration;
    Parameter: ParameterDeclaration;
    Decorator: Decorator;
    PropertySignature: PropertySignature;
    PropertyDeclaration: PropertyDeclaration;
    MethodSignature: MethodSignature;
    MethodDeclaration: MethodDeclaration;
    ClassStaticBlockDeclaration: ClassStaticBlockDeclaration;
    Constructor: ConstructorDeclaration;
    GetAccessor: GetAccessorDeclaration;
    SetAccessor: SetAccessorDeclaration;
    CallSignature: CallSignatureDeclaration;
    ConstructSignature: ConstructSignatureDeclaration;
    IndexSignature: IndexSignatureDeclaration;
    TypePredicate: TypePredicateNode;
    TypeReference: TypeReferenceNode;
    FunctionType: FunctionTypeNode;
    ConstructorType: ConstructorTypeNode;
    TypeQuery: TypeQueryNode;
    TypeLiteral: TypeLiteralNode;
    ArrayType: ArrayTypeNode;
    TupleType: TupleTypeNode;
    OptionalType: OptionalTypeNode;
    RestType: RestTypeNode;
    UnionType: UnionTypeNode;
    IntersectionType: IntersectionTypeNode;
    ConditionalType: ConditionalTypeNode;
    InferType: InferTypeNode;
    ParenthesizedType: ParenthesizedTypeNode;
    ThisType: ThisTypeNode;
    TypeOperator: TypeOperatorNode;
    IndexedAccessType: IndexedAccessTypeNode;
    MappedType: MappedTypeNode;
    LiteralType: LiteralTypeNode;
    NamedTupleMember: NamedTupleMember;
    TemplateLiteralType: TemplateLiteralTypeNode;
    TemplateLiteralTypeSpan: TemplateLiteralTypeSpan;
    ImportType: ImportTypeNode;
    ObjectBindingPattern: ObjectBindingPattern;
    ArrayBindingPattern: ArrayBindingPattern;
    BindingElement: BindingElement;
    ArrayLiteralExpression: ArrayLiteralExpression;
    ObjectLiteralExpression: ObjectLiteralExpression;
    PropertyAccessExpression: PropertyAccessExpression;
    ElementAccessExpression: ElementAccessExpression;
    CallExpression: CallExpression;
    NewExpression: NewExpression;
    TaggedTemplateExpression: TaggedTemplateExpression;
    TypeAssertionExpression: TypeAssertion;
    ParenthesizedExpression: ParenthesizedExpression;
    FunctionExpression: FunctionExpression;
    ArrowFunction: ArrowFunction;
    DeleteExpression: DeleteExpression;
    TypeOfExpression: TypeOfExpression;
    VoidExpression: VoidExpression;
    AwaitExpression: AwaitExpression;
    PrefixUnaryExpression: PrefixUnaryExpression;
    PostfixUnaryExpression: PostfixUnaryExpression;
    BinaryExpression: BinaryExpression;
    ConditionalExpression: ConditionalExpression;
    TemplateExpression: TemplateExpression;
    YieldExpression: YieldExpression;
    SpreadElement: SpreadElement;
    ClassExpression: ClassExpression;
    OmittedExpression: OmittedExpression;
    ExpressionWithTypeArguments: ExpressionWithTypeArguments;
    AsExpression: AsExpression;
    NonNullExpression: NonNullExpression;
    MetaProperty: MetaProperty;
    SyntheticExpression: SyntheticExpression;
    SatisfiesExpression: SatisfiesExpression;
    TemplateSpan: TemplateSpan;
    SemicolonClassElement: SemicolonClassElement;
    Block: Block;
    EmptyStatement: EmptyStatement;
    VariableStatement: VariableStatement;
    ExpressionStatement: ExpressionStatement;
    IfStatement: IfStatement;
    DoStatement: DoStatement;
    WhileStatement: WhileStatement;
    ForStatement: ForStatement;
    ForInStatement: ForInStatement;
    ForOfStatement: ForOfStatement;
    ContinueStatement: ContinueStatement;
    BreakStatement: BreakStatement;
    ReturnStatement: ReturnStatement;
    WithStatement: WithStatement;
    SwitchStatement: SwitchStatement;
    LabeledStatement: LabeledStatement;
    ThrowStatement: ThrowStatement;
    TryStatement: TryStatement;
    DebuggerStatement: DebuggerStatement;
    VariableDeclaration: VariableDeclaration;
    VariableDeclarationList: VariableDeclarationList;
    FunctionDeclaration: FunctionDeclaration;
    ClassDeclaration: ClassDeclaration;
    InterfaceDeclaration: InterfaceDeclaration;
    TypeAliasDeclaration: TypeAliasDeclaration;
    EnumDeclaration: EnumDeclaration;
    ModuleDeclaration: ModuleDeclaration;
    ModuleBlock: ModuleBlock;
    CaseBlock: CaseBlock;
    NamespaceExportDeclaration: NamespaceExportDeclaration;
    ImportEqualsDeclaration: ImportEqualsDeclaration;
    ImportDeclaration: ImportDeclaration;
    ImportClause: ImportClause;
    NamespaceImport: NamespaceImport;
    NamedImports: NamedImports;
    ImportSpecifier: ImportSpecifier;
    ExportAssignment: ExportAssignment;
    ExportDeclaration: ExportDeclaration;
    NamedExports: NamedExports;
    NamespaceExport: NamespaceExport;
    ExportSpecifier: ExportSpecifier;
    MissingDeclaration: MissingDeclaration;
    ExternalModuleReference: ExternalModuleReference;
    JsxElement: JsxElement;
    JsxSelfClosingElement: JsxSelfClosingElement;
    JsxOpeningElement: JsxOpeningElement;
    JsxClosingElement: JsxClosingElement;
    JsxFragment: JsxFragment;
    JsxOpeningFragment: JsxOpeningFragment;
    JsxClosingFragment: JsxClosingFragment;
    JsxAttribute: JsxAttribute;
    JsxAttributes: JsxAttributes;
    JsxSpreadAttribute: JsxSpreadAttribute;
    JsxExpression: JsxExpression;
    JsxNamespacedName: JsxNamespacedName;
    CaseClause: CaseClause;
    DefaultClause: DefaultClause;
    HeritageClause: HeritageClause;
    CatchClause: CatchClause;
    ImportAttributes: ImportAttributes;
    ImportAttribute: ImportAttribute;
    /** @deprecated */ AssertClause: AssertClause;
    /** @deprecated */ AssertEntry: AssertEntry;
    /** @deprecated */ ImportTypeAssertionContainer: ImportTypeAssertionContainer;
    PropertyAssignment: PropertyAssignment;
    ShorthandPropertyAssignment: ShorthandPropertyAssignment;
    SpreadAssignment: SpreadAssignment;
    EnumMember: EnumMember;
    SourceFile: SourceFile;
    Bundle: Bundle;
    JSDocTypeExpression: JSDocTypeExpression;
    JSDocNameReference: JSDocNameReference;
    JSDocMemberName: JSDocMemberName;
    JSDocAllType: JSDocAllType;
    JSDocUnknownType: JSDocUnknownType;
    JSDocNullableType: JSDocNullableType;
    JSDocNonNullableType: JSDocNonNullableType;
    JSDocOptionalType: JSDocOptionalType;
    JSDocFunctionType: JSDocFunctionType;
    JSDocVariadicType: JSDocVariadicType;
    JSDocNamepathType: JSDocNamepathType;
    JSDoc: JSDoc;
    /** @deprecated Use JSDoc */
    JSDocComment: never;
    JSDocText: JSDocText;
    JSDocTypeLiteral: JSDocTypeLiteral;
    JSDocSignature: JSDocSignature;
    JSDocLink: JSDocLink;
    JSDocLinkCode: JSDocLinkCode;
    JSDocLinkPlain: JSDocLinkPlain;
    JSDocTag: never;
    JSDocAugmentsTag: JSDocAugmentsTag;
    JSDocImplementsTag: JSDocImplementsTag;
    JSDocAuthorTag: JSDocAuthorTag;
    JSDocDeprecatedTag: JSDocDeprecatedTag;
    JSDocClassTag: JSDocClassTag;
    JSDocPublicTag: JSDocPublicTag;
    JSDocPrivateTag: JSDocPrivateTag;
    JSDocProtectedTag: JSDocProtectedTag;
    JSDocReadonlyTag: JSDocReadonlyTag;
    JSDocOverrideTag: JSDocOverrideTag;
    JSDocCallbackTag: JSDocCallbackTag;
    JSDocOverloadTag: JSDocOverloadTag;
    JSDocEnumTag: JSDocEnumTag;
    JSDocParameterTag: JSDocParameterTag;
    JSDocReturnTag: JSDocReturnTag;
    JSDocThisTag: JSDocThisTag;
    JSDocTypeTag: JSDocTypeTag;
    JSDocTemplateTag: JSDocTemplateTag;
    JSDocTypedefTag: JSDocTypedefTag;
    JSDocSeeTag: JSDocSeeTag;
    JSDocPropertyTag: JSDocPropertyTag;
    JSDocThrowsTag: JSDocThrowsTag;
    JSDocSatisfiesTag: JSDocSatisfiesTag;
    JSDocImportTag: JSDocImportTag;
    SyntaxList: SyntaxList;
    NotEmittedStatement: NotEmittedStatement;
    NotEmittedTypeElement: NotEmittedTypeElement;
    PartiallyEmittedExpression: PartiallyEmittedExpression;
    CommaListExpression: CommaListExpression;
    // unused
    SyntheticReferenceExpression: never;
    Count: never;
    // markers
    FirstAssignment: never;
    LastAssignment: never;
    FirstCompoundAssignment: never;
    LastCompoundAssignment: never;
    FirstReservedWord: never;
    LastReservedWord: never;
    FirstKeyword: never;
    LastKeyword: never;
    FirstFutureReservedWord: never;
    LastFutureReservedWord: never;
    FirstTypeNode: never;
    LastTypeNode: never;
    FirstPunctuation: never;
    LastPunctuation: never;
    FirstToken: never;
    LastToken: never;
    FirstTriviaToken: never;
    LastTriviaToken: never;
    FirstLiteralToken: never;
    LastLiteralToken: never;
    FirstTemplateToken: never;
    LastTemplateToken: never;
    FirstBinaryOperator: never;
    LastBinaryOperator: never;
    FirstStatement: never;
    LastStatement: never;
    FirstNode: never;
    FirstJSDocNode: never;
    LastJSDocNode: never;
    FirstJSDocTagNode: never;
    LastJSDocTagNode: never;
}

type _ = StringLiteral["text"];

// mostly markers, some random other things
type InvalidTypes = keyof {
    [K in keyof UnmappedNodeTypes as[UnmappedNodeTypes[K]] extends [never] ? K : never]: never;
};

export type MappedNodeTypes = {
    [K in keyof UnmappedNodeTypes as [UnmappedNodeTypes[K]] extends [never] ? never : K]: MapNode<UnmappedNodeTypes[K]>;
};
export type NodeTypes = MappedNodeTypes[keyof MappedNodeTypes];
